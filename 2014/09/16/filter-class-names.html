<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Filter Class Names</title><meta name=description content="Go Golang Code Examples programming"><meta name=viewport content="width=device-width"><link rel="shortcut icon" href=/golang-code-examples/favicon.ico type=image/x-icon><link rel=icon href=/golang-code-examples/favicon.ico type=image/x-icon><link rel=stylesheet href=/golang-code-examples/styles/main.d9bf.css><script src=https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js></script><!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><meta name=viewport content="width=device-width, initial-scale=1, user-scalable=no"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-53073815-1', 'auto');
        ga('send', 'pageview');</script></head><body><div id=dialogoverlay class=dialogoverlay></div><div id=dialogbox class=dialogbox><div><div id=dialogboxhead class=dialogboxhead></div><div id=dialogboxbody class=dialogboxbody></div><div id=dialogboxfoot class=dialogboxfoot></div></div></div><div class=site><header><h1><a class=home-link href="/golang-code-examples">Golang Code Examples</a></h1></header><div id=banner><span id=logo></span> <a href=https://github.com/l3x/golang-code-examples class="button fork"><strong>View On GitHub</strong></a><div class=downloads><span>Downloads:</span><ul><li><a href=https://github.com/l3x/golang-code-examples/zipball/master class=button>ZIP</a></li><li><a href=https://github.com/l3x/golang-code-examples/tarball/master class=button>TAR</a></li></ul></div></div><!-- end banner --><div class=wrapper><nav><ul></ul></nav><div class=page-title><h2>Filter Class Names</h2><p class=meta>16 Sep 2014</p></div><div class=post><section><h2>Description</h2><p>This example demonstrates how to implement a class name filter (aka class navigation), like the one you see in many Eclipse-based IDEs.</p><p><img src=https://raw.githubusercontent.com/l3x/golang-code-examples/master/eclipse-class-filter.png alt=pta></p><h3>Usage Instructions</h3><p>To open any class in the editor quickly, press âŒ˜O (Navigate | Class) and start typing the name of the class. Choose the class from a drop-down list that appears.</p><p>This diaglog allows you to quickly filter out classes based on the text you enter.</p><p>Your input string must begin with an upper case alpha (A-Z) letter.</p><p>The next letter may be upper or lower case.</p><p>If it is lower case, then all sequential lower case letters that you enter will match exactly to the lower case letters found in the class name.</p><p>If you enter an upper case letter, then it will find the next upper case letter (ignoring any lower case letters in between your previous match an the matching upper case letter.)<br></p><h3>Design Goals</h3><ul><li>Make something that works</li><li>Make it so that there is little performance hit, no matter how many class names are added</li></ul><p><br></p><h3>Strategy</h3><p>Use levels of maps of each letter in the alphabet that can be traversed to find the stored class names.</p><p>Sharding large sets of data is typically a good idea if you want to increase performance, but that works when different data sets can be separately loaded and processed and orchestrated back together.</p><p>Perhaps, just using a single map would have sufficed, but this was after all just a code example.</p><p>Maybe our next code example can run performance tests against this solution and a single map solution.</p><p><br><hr></p><h2>Golang Features</h2><p>This golang code sample demonstrates the following go language features:</p><ul><li>switch</li><li>struct</li><li>slice</li><li>map</li><li>pointers</li><li>range</li><li>substring</li><li>fmt</li></ul><p><br><hr></p><h2>3rd Party Libraries</h2><ul><li>github.com/remogatto/prettytest</li><li>github.com/go-goodies/go_utils</li></ul><p><br>Note that we preface github.com/go-goodies/go_utils with a &quot;.&quot; which makes its functions directly accessible in our go program without prefacing it with any package name alias.</p><p>Now, we can reference go_utils functions like so: c = <strong>IndexOf(input[i:i+1], className, c+1)</strong></p><p>Which, by the way, returns the index of the current input character input[i:i+1] found in the string, className, starting at the index of c+1.</p><p><br><hr><br></p><h2>Code Example</h2><h3>classname_filter.go</h3><div class=highlight><pre><code class="go language-go" data-lang=go><span class=kn>package</span> <span class=nx>class_filter</span>  <span class=c1>// main</span>

<span class=kn>import</span> <span class=p>(</span>
    <span class=p>.</span> <span class=s>&quot;fmt&quot;</span>
    <span class=p>.</span> <span class=s>&quot;github.com/go-goodies/go_utils&quot;</span>
<span class=p>)</span>

<span class=kd>var</span> <span class=p>(</span>
    <span class=nx>tree</span> <span class=o>*</span><span class=nx>Tree</span>
<span class=p>)</span>

<span class=c1>// Level is the node that contains the alpha map for each level</span>
<span class=c1>// Each level contains words that match that level&#39;s levelNumber</span>
<span class=c1>// The first letter of each entry in the alpha map matches that key, e.g. &quot;Hi&quot; is at level 2 at key &quot;H&quot;</span>
<span class=kd>type</span> <span class=nx>Level</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>alpha</span>       <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span>  <span class=c1>// a, b, ..z, A, B .. Z =&gt; HelloWorld, HiWorld, WordlHello, HelloWeirWorld</span>
    <span class=nx>levelNumber</span> <span class=kt>int</span>
    <span class=nx>nextLevel</span>   <span class=o>*</span><span class=nx>Level</span>
<span class=p>}</span>

<span class=c1>// Tree contains the pointer to the top of the tree of levels</span>
<span class=kd>type</span> <span class=nx>Tree</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>top</span>     <span class=o>*</span><span class=nx>Level</span>
<span class=p>}</span>
<span class=c1>// The Top() method points to the top of the tree. (Only downward navigation is supported)</span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>tree</span> <span class=o>*</span><span class=nx>Tree</span><span class=p>)</span> <span class=nx>Top</span><span class=p>()</span> <span class=o>*</span><span class=nx>Level</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>tree</span><span class=p>.</span><span class=nx>top</span>
<span class=p>}</span>

<span class=c1>// PopulateAlphas populates the alphas map (one per level) with one letter per ALPHABET</span>
<span class=kd>func</span> <span class=nx>PopulateAlphas</span><span class=p>()</span> <span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>alphas</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span>
    <span class=kd>var</span> <span class=nx>thisChar</span> <span class=kt>string</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>c</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ALPHABET</span> <span class=p>{</span>
        <span class=nx>thisChar</span> <span class=p>=</span> <span class=nx>Sprintf</span><span class=p>(</span><span class=s>&quot;%c&quot;</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
        <span class=nx>alphas</span><span class=p>[</span><span class=nx>thisChar</span><span class=p>]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>alphas</span>
<span class=p>}</span>

<span class=c1>// PrintAlpha only prints letters that store classNames</span>
<span class=kd>func</span> <span class=nx>PrintAlpha</span><span class=p>(</span><span class=nx>alpha</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>,</span> <span class=nx>levelNumber</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=nx>thisChar</span> <span class=kt>string</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>c</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ALPHABET</span> <span class=p>{</span>
        <span class=nx>thisChar</span> <span class=p>=</span> <span class=nx>Sprintf</span><span class=p>(</span><span class=s>&quot;%c&quot;</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>alpha</span><span class=p>[</span><span class=nx>thisChar</span><span class=p>])</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
            <span class=nx>Printf</span><span class=p>(</span><span class=s>&quot;alpha[%s] (%d) : %v\n&quot;</span><span class=p>,</span> <span class=nx>thisChar</span><span class=p>,</span> <span class=nx>levelNumber</span><span class=p>,</span> <span class=nx>alpha</span><span class=p>[</span><span class=nx>thisChar</span><span class=p>]</span> <span class=p>)</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=cm>/*</span>
<span class=cm>  Example:</span>
<span class=cm>  alpha[H] (6) : map[HiWorld:HiWorld]</span>
<span class=cm>  alpha[H] (9) : map[HelloWorld:HelloWorld]</span>
<span class=cm>  alpha[W] (9) : map[WordlHello:WordlHello]</span>
<span class=cm>  alpha[H] (13) : map[HelloWeirWorld:HelloWeirWorld]</span>
<span class=cm>*/</span>
<span class=c1>// PrintTree prints the elements containing data for the alphas map, prefaced with (level_number)</span>
<span class=kd>func</span> <span class=nx>PrintTree</span><span class=p>(</span><span class=nx>tree</span> <span class=nx>Tree</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span> <span class=nx>level</span> <span class=o>:=</span> <span class=nx>tree</span><span class=p>.</span><span class=nx>Top</span><span class=p>();</span> <span class=nx>level</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>;</span> <span class=nx>level</span> <span class=p>=</span> <span class=nx>level</span><span class=p>.</span><span class=nx>nextLevel</span> <span class=p>{</span>
        <span class=nx>PrintAlpha</span><span class=p>(</span><span class=nx>level</span><span class=p>.</span><span class=nx>alpha</span><span class=p>,</span> <span class=nx>level</span><span class=p>.</span><span class=nx>levelNumber</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>


<span class=c1>// PopulateTree stores each className in the tree at the level equal to the length at alpha[first_letter_of_classname]</span>
<span class=kd>func</span> <span class=nx>PopulateTree</span><span class=p>(</span><span class=nx>classNames</span> <span class=p>[]</span><span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>Tree</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>alphas</span> <span class=o>:=</span> <span class=nx>PopulateAlphas</span><span class=p>()</span>
    <span class=nx>tree</span> <span class=o>:=</span> <span class=nb>new</span><span class=p>(</span><span class=nx>Tree</span><span class=p>)</span>
    <span class=nx>tree</span><span class=p>.</span><span class=nx>top</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>Level</span><span class=p>{</span><span class=nx>DeepCopy</span><span class=p>(</span><span class=nx>alphas</span><span class=p>).(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>),</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>nil</span><span class=p>}</span>  <span class=c1>// startPos with level0 alpha map ready</span>
    <span class=nx>thisLevel</span> <span class=o>:=</span> <span class=nx>tree</span><span class=p>.</span><span class=nx>Top</span><span class=p>()</span>
    <span class=kd>var</span> <span class=nx>curLevelNumber</span> <span class=kt>int</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>className</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>classNames</span> <span class=p>{</span>
        <span class=nx>thisLevel</span> <span class=p>=</span> <span class=nx>tree</span><span class=p>.</span><span class=nx>Top</span><span class=p>()</span>
        <span class=nx>curLevelNumber</span> <span class=p>=</span> <span class=mi>0</span>
        <span class=c1>// loop thru each letter of className</span>
        <span class=c1>// - if this is the last letter, store the className on this level in alpha[first_letter_of_className]</span>
        <span class=c1>// - else if nextLevel is nil then create a new Level and point nextLevel to it</span>
        <span class=k>for</span> <span class=nx>c</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>c</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>className</span><span class=p>);</span> <span class=nx>c</span><span class=o>++</span> <span class=p>{</span>
            <span class=c1>// thisLetter := Sprintf(&quot;%s&quot;, className[c:c+1])</span>
            <span class=k>if</span> <span class=nx>c</span> <span class=o>==</span> <span class=nb>len</span><span class=p>(</span><span class=nx>className</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span> <span class=p>{</span>
                <span class=c1>// store className as key and as value</span>
                <span class=nx>thisLevel</span><span class=p>.</span><span class=nx>alpha</span><span class=p>[</span><span class=nx>className</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=mi>1</span><span class=p>]][</span><span class=nx>className</span><span class=p>]</span> <span class=p>=</span> <span class=nx>className</span>
            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                <span class=c1>// must keep going, populate nextLevel and set levelNumber if nextLevel is nil</span>
                <span class=nx>curLevelNumber</span> <span class=o>+=</span> <span class=mi>1</span>
                <span class=k>if</span> <span class=nx>thisLevel</span><span class=p>.</span><span class=nx>nextLevel</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
                    <span class=nx>thisLevel</span><span class=p>.</span><span class=nx>nextLevel</span> <span class=p>=</span> <span class=o>&amp;</span><span class=nx>Level</span><span class=p>{</span><span class=nx>DeepCopy</span><span class=p>(</span><span class=nx>alphas</span><span class=p>).(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>),</span> <span class=nx>curLevelNumber</span><span class=p>,</span> <span class=kc>nil</span><span class=p>}</span>
                <span class=p>}</span>
                <span class=nx>thisLevel</span> <span class=p>=</span> <span class=nx>thisLevel</span><span class=p>.</span><span class=nx>nextLevel</span>
            <span class=p>}</span>
            <span class=c1>//Printf(&quot;thisLevel: %v\n&quot;, *thisLevel)</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>tree</span>
<span class=p>}</span>


<span class=c1>// FindClassNames uses global tree</span>
<span class=kd>func</span> <span class=nx>FindClassNames</span><span class=p>(</span><span class=nx>input</span> <span class=kt>string</span><span class=p>)</span> <span class=p>([]</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// First (cap) letter must be on level0</span>
    <span class=kd>var</span> <span class=nx>levelsFound</span> <span class=p>[]</span><span class=kt>int</span>
    <span class=kd>var</span> <span class=nx>classNames</span> <span class=p>[]</span><span class=kt>string</span>
    <span class=nx>ptr</span> <span class=o>:=</span> <span class=nx>tree</span><span class=p>.</span><span class=nx>Top</span><span class=p>()</span>
    <span class=nx>ptr</span> <span class=p>=</span> <span class=nx>ptr</span><span class=p>.</span><span class=nx>nextLevel</span>

    <span class=k>for</span> <span class=nx>level</span> <span class=o>:=</span> <span class=nx>tree</span><span class=p>.</span><span class=nx>Top</span><span class=p>();</span> <span class=nx>level</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>;</span> <span class=nx>level</span> <span class=p>=</span> <span class=nx>level</span><span class=p>.</span><span class=nx>nextLevel</span> <span class=p>{</span>
        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>level</span><span class=p>.</span><span class=nx>alpha</span><span class=p>[</span><span class=nx>input</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=mi>1</span><span class=p>]])</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
            <span class=nx>levelsFound</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>levelsFound</span><span class=p>,</span> <span class=nx>level</span><span class=p>.</span><span class=nx>levelNumber</span><span class=p>)</span>
            <span class=k>for</span> <span class=nx>k</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>level</span><span class=p>.</span><span class=nx>alpha</span><span class=p>[</span><span class=nx>input</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=mi>1</span><span class=p>]]</span> <span class=p>{</span>
                <span class=c1>// className is the key (level.alpha[input[input[0:1]]: map[Hi:])</span>
                <span class=nx>classNames</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>classNames</span><span class=p>,</span> <span class=nx>k</span><span class=p>)</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=c1>//  Printf(&quot;levelsFound for input[0:1] (%s): %v\n&quot;, input[0:1],levelsFound)</span>
<span class=c1>//  Printf(&quot;classNames: %v\n&quot;, classNames)</span>
    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>input</span><span class=p>)</span> <span class=o>==</span> <span class=mi>1</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>classNames</span>
    <span class=p>}</span>

    <span class=c1>// Start with slice of classNames that match 1st letter, now on to 2nd letter...and whittle it down</span>
    <span class=kd>var</span> <span class=nx>passingClassNames</span> <span class=p>[]</span><span class=kt>string</span>
    <span class=nx>fail</span> <span class=o>:=</span> <span class=kc>false</span>

    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>className</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>classNames</span> <span class=p>{</span>

        <span class=c1>// Iterate thru each letter of input (i is input iterator)</span>
        <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>input</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>fail</span><span class=p>;</span> <span class=p>{</span>

            <span class=c1>// Move thru each letter of className (c is className iterator)</span>
            <span class=k>for</span> <span class=nx>c</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>input</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nx>c</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>className</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>!</span><span class=nx>fail</span><span class=p>;</span> <span class=p>{</span>

                <span class=c1>//Printf(&quot;*** input[i:i+1]: %s, className[c:c+1]: %s\n&quot;, input[i:i+1], className[c:c+1])</span>
                <span class=k>if</span> <span class=nx>input</span><span class=p>[</span><span class=nx>i</span><span class=p>:</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=nx>className</span><span class=p>[</span><span class=nx>c</span><span class=p>:</span><span class=nx>c</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=p>{</span>
                    <span class=c1>// happy path (matching characters)</span>
                    <span class=nx>i</span> <span class=o>+=</span> <span class=mi>1</span>
                    <span class=nx>c</span> <span class=o>+=</span> <span class=mi>1</span>
                <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>!</span><span class=nx>IsLower</span><span class=p>(</span><span class=nx>input</span><span class=p>[</span><span class=nx>i</span><span class=p>:</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>])</span> <span class=p>{</span>
                    <span class=c1>// at upper case input character</span>
                    <span class=nx>c</span> <span class=p>=</span> <span class=nx>IndexOf</span><span class=p>(</span><span class=nx>input</span><span class=p>[</span><span class=nx>i</span><span class=p>:</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>],</span> <span class=nx>className</span><span class=p>,</span> <span class=nx>c</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span>
                    <span class=k>if</span> <span class=nx>c</span> <span class=o>==</span> <span class=nx>NOT_FOUND_INDEX</span> <span class=p>{</span>
                        <span class=c1>//Println(&quot;c == NOT_FOUND_INDEX&quot;)</span>
                        <span class=nx>fail</span> <span class=p>=</span> <span class=kc>true</span>
                    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                        <span class=nx>i</span> <span class=o>+=</span> <span class=mi>1</span>
                        <span class=nx>c</span> <span class=o>+=</span> <span class=mi>1</span>
                    <span class=p>}</span>
                <span class=p>}</span> <span class=k>else</span>  <span class=p>{</span>
                    <span class=nx>fail</span> <span class=p>=</span> <span class=kc>true</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=p>!</span><span class=nx>fail</span> <span class=p>{</span><span class=nx>passingClassNames</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>passingClassNames</span><span class=p>,</span> <span class=nx>className</span><span class=p>)}</span>
        <span class=nx>fail</span> <span class=p>=</span> <span class=kc>false</span>
    <span class=p>}</span>
    <span class=c1>//classNames := []string{&quot;HelloWorld&quot;, &quot;HiWorld&quot;}</span>
    <span class=k>return</span> <span class=nx>passingClassNames</span>
<span class=p>}</span>

<span class=cm>/* </span>
<span class=cm>    Helper functions</span>
<span class=cm> */</span>
<span class=kd>func</span> <span class=nx>PrintClassNames</span><span class=p>(</span><span class=nx>classNames</span> <span class=p>[]</span><span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>className</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>classNames</span> <span class=p>{</span>
        <span class=nx>Printf</span><span class=p>(</span><span class=s>&quot;%s\n&quot;</span><span class=p>,</span> <span class=nx>className</span><span class=p>)</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nx>FindAndPrintClassNames</span><span class=p>(</span><span class=nx>input</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>Printf</span><span class=p>(</span><span class=s>&quot;ClassNames found for input: %s\n&quot;</span><span class=p>,</span> <span class=nx>input</span><span class=p>)</span>
    <span class=nx>foundClassNames</span> <span class=o>:=</span> <span class=nx>FindClassNames</span><span class=p>(</span><span class=nx>input</span><span class=p>)</span>
    <span class=nx>PrintClassNames</span><span class=p>(</span><span class=nx>foundClassNames</span><span class=p>)</span>
    <span class=nx>Println</span><span class=p>(</span><span class=nx>Dashes</span><span class=p>(</span><span class=mi>50</span><span class=p>))</span>
<span class=p>}</span>


<span class=kd>func</span> <span class=nx>mainSTOP</span><span class=p>()</span> <span class=p>{</span>

    <span class=c1>// Insert ClassNames in tree structure</span>
    <span class=nx>classNames</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&quot;HelloWorld&quot;</span><span class=p>,</span> <span class=s>&quot;HiWorld&quot;</span><span class=p>,</span> <span class=s>&quot;WordlHello&quot;</span><span class=p>,</span> <span class=s>&quot;HelloWeirWorld&quot;</span><span class=p>}</span>
    <span class=nx>tree</span> <span class=p>=</span> <span class=nx>PopulateTree</span><span class=p>(</span><span class=nx>classNames</span><span class=p>)</span>

    <span class=nx>Println</span><span class=p>(</span><span class=s>&quot;TREE:&quot;</span><span class=p>)</span>
    <span class=nx>PrintTree</span><span class=p>(</span><span class=o>*</span><span class=nx>tree</span><span class=p>)</span>

    <span class=nx>Println</span><span class=p>(</span><span class=nx>Dashes</span><span class=p>(</span><span class=mi>50</span><span class=p>))</span>
    <span class=nx>FindAndPrintClassNames</span><span class=p>(</span><span class=s>&quot;HW&quot;</span><span class=p>)</span>
    <span class=nx>FindAndPrintClassNames</span><span class=p>(</span><span class=s>&quot;He&quot;</span><span class=p>)</span>
    <span class=nx>FindAndPrintClassNames</span><span class=p>(</span><span class=s>&quot;Hi&quot;</span><span class=p>)</span>
    <span class=nx>FindAndPrintClassNames</span><span class=p>(</span><span class=s>&quot;HWW&quot;</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p><br><hr><br></p><h2>Test Code</h2><h3>classname<em>filter</em>test.go</h3><div class=highlight><pre><code class="go language-go" data-lang=go><span class=kn>package</span> <span class=nx>class_filter</span>

<span class=kn>import</span> <span class=p>(</span>
    <span class=s>&quot;testing&quot;</span>
    <span class=s>&quot;github.com/remogatto/prettytest&quot;</span>
    <span class=p>.</span> <span class=s>&quot;github.com/go-goodies/go_utils&quot;</span>
    <span class=p>.</span> <span class=s>&quot;fmt&quot;</span>
<span class=p>)</span>

<span class=kd>var</span> <span class=p>(</span>
    <span class=nx>classNames</span> <span class=p>[]</span><span class=kt>string</span>
<span class=c1>//  tree *Tree</span>
<span class=p>)</span>

<span class=kd>func</span> <span class=nx>init</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// Insert ClassNames in tree structure</span>
    <span class=nx>classNames</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>string</span><span class=p>{</span><span class=s>&quot;HelloWorld&quot;</span><span class=p>,</span> <span class=s>&quot;HiWorld&quot;</span><span class=p>,</span> <span class=s>&quot;WordlHello&quot;</span><span class=p>,</span> <span class=s>&quot;HelloWeirWorld&quot;</span><span class=p>}</span>
    <span class=nx>tree</span> <span class=p>=</span> <span class=nx>PopulateTree</span><span class=p>(</span><span class=nx>classNames</span><span class=p>)</span>
<span class=p>}</span>

<span class=kd>type</span> <span class=nx>mySuite</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>prettytest</span><span class=p>.</span><span class=nx>Suite</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=nx>TestRunner</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>testing</span><span class=p>.</span><span class=nx>T</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>prettytest</span><span class=p>.</span><span class=nx>Run</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nb>new</span><span class=p>(</span><span class=nx>mySuite</span><span class=p>))</span>
<span class=p>}</span>

<span class=cm>/*</span>
<span class=cm>    // Insert ClassNames in tree structure</span>
<span class=cm>    classNames := []string{&quot;HelloWorld&quot;, &quot;HiWorld&quot;, &quot;WordlHello&quot;, &quot;HelloWeirWorld&quot;}</span>
<span class=cm>    tree = PopulateTree(classNames)</span>
<span class=cm> */</span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>mySuite</span><span class=p>)</span> <span class=nx>TestPopulateTree</span><span class=p>()</span> <span class=p>{</span>

    <span class=k>for</span> <span class=nx>level</span> <span class=o>:=</span> <span class=nx>tree</span><span class=p>.</span><span class=nx>Top</span><span class=p>();</span> <span class=nx>level</span> <span class=o>!=</span> <span class=kc>nil</span><span class=p>;</span> <span class=nx>level</span> <span class=p>=</span> <span class=nx>level</span><span class=p>.</span><span class=nx>nextLevel</span> <span class=p>{</span>
        <span class=c1>//PrintAlpha(level.alpha, level.levelNumber)</span>
        <span class=kd>var</span> <span class=nx>thisChar</span> <span class=kt>string</span>
        <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>c</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>ALPHABET</span> <span class=p>{</span>
            <span class=nx>thisChar</span> <span class=p>=</span> <span class=nx>Sprintf</span><span class=p>(</span><span class=s>&quot;%c&quot;</span><span class=p>,</span> <span class=nx>c</span><span class=p>)</span>
            <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>level</span><span class=p>.</span><span class=nx>alpha</span><span class=p>[</span><span class=nx>thisChar</span><span class=p>])</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
                <span class=c1>//s.Error(Sprintf(&quot;***: level.alpha[%s]: %v, level.levelNumber: %d&quot;, thisChar, level.alpha[thisChar], level.levelNumber))</span>
                <span class=k>if</span> <span class=nx>level</span><span class=p>.</span><span class=nx>alpha</span><span class=p>[</span><span class=nx>thisChar</span><span class=p>][</span><span class=s>&quot;HelloWorld&quot;</span><span class=p>]</span> <span class=o>==</span> <span class=s>&quot;HelloWorld&quot;</span> <span class=p>{</span>
                    <span class=nx>s</span><span class=p>.</span><span class=nx>Equal</span><span class=p>(</span><span class=nx>level</span><span class=p>.</span><span class=nx>levelNumber</span><span class=p>,</span> <span class=mi>9</span><span class=p>)</span>
                <span class=p>}</span>
                <span class=k>if</span> <span class=nx>level</span><span class=p>.</span><span class=nx>alpha</span><span class=p>[</span><span class=nx>thisChar</span><span class=p>][</span><span class=s>&quot;HiWorld&quot;</span><span class=p>]</span> <span class=o>==</span> <span class=s>&quot;HiWorld&quot;</span> <span class=p>{</span>
                    <span class=nx>s</span><span class=p>.</span><span class=nx>Equal</span><span class=p>(</span><span class=nx>level</span><span class=p>.</span><span class=nx>levelNumber</span><span class=p>,</span> <span class=mi>6</span><span class=p>)</span>
                <span class=p>}</span>
                <span class=k>if</span> <span class=nx>level</span><span class=p>.</span><span class=nx>alpha</span><span class=p>[</span><span class=nx>thisChar</span><span class=p>][</span><span class=s>&quot;WordlHello&quot;</span><span class=p>]</span> <span class=o>==</span> <span class=s>&quot;WordlHello&quot;</span> <span class=p>{</span>
                    <span class=nx>s</span><span class=p>.</span><span class=nx>Equal</span><span class=p>(</span><span class=nx>level</span><span class=p>.</span><span class=nx>levelNumber</span><span class=p>,</span> <span class=mi>9</span><span class=p>)</span>
                <span class=p>}</span>
                <span class=k>if</span> <span class=nx>level</span><span class=p>.</span><span class=nx>alpha</span><span class=p>[</span><span class=nx>thisChar</span><span class=p>][</span><span class=s>&quot;HelloWeirWorld&quot;</span><span class=p>]</span> <span class=o>==</span> <span class=s>&quot;HelloWeirWorld&quot;</span> <span class=p>{</span>
                    <span class=nx>s</span><span class=p>.</span><span class=nx>Equal</span><span class=p>(</span><span class=nx>level</span><span class=p>.</span><span class=nx>levelNumber</span><span class=p>,</span> <span class=mi>13</span><span class=p>)</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>mySuite</span><span class=p>)</span> <span class=nx>TestClassNameFilter</span><span class=p>()</span> <span class=p>{</span>

    <span class=kd>var</span> <span class=nx>thisIndex</span> <span class=kt>int</span>
    <span class=kd>var</span> <span class=nx>foundClassNames</span> <span class=p>[]</span><span class=kt>string</span>
    <span class=nx>foundClassNames</span> <span class=p>=</span> <span class=nx>FindClassNames</span><span class=p>(</span><span class=s>&quot;HW&quot;</span><span class=p>)</span>

    <span class=nx>thisIndex</span> <span class=p>=</span> <span class=nx>IndexOfGeneric</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>foundClassNames</span><span class=p>),</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>foundClassNames</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=s>&quot;HiWorld&quot;</span> <span class=p>})</span>
    <span class=nx>s</span><span class=p>.</span><span class=nx>Equal</span><span class=p>(</span><span class=nx>thisIndex</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>

    <span class=nx>thisIndex</span> <span class=p>=</span> <span class=nx>IndexOfGeneric</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>foundClassNames</span><span class=p>),</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>foundClassNames</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=s>&quot;HelloWorld&quot;</span> <span class=p>})</span>
    <span class=nx>s</span><span class=p>.</span><span class=nx>Equal</span><span class=p>(</span><span class=nx>thisIndex</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>

    <span class=nx>thisIndex</span> <span class=p>=</span> <span class=nx>IndexOfGeneric</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>foundClassNames</span><span class=p>),</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>foundClassNames</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=s>&quot;HelloWeirWorld&quot;</span> <span class=p>})</span>
    <span class=nx>s</span><span class=p>.</span><span class=nx>Equal</span><span class=p>(</span><span class=nx>thisIndex</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>

    <span class=nx>s</span><span class=p>.</span><span class=nx>Equal</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>foundClassNames</span><span class=p>),</span> <span class=mi>3</span><span class=p>)</span>


    <span class=nx>foundClassNames</span> <span class=p>=</span> <span class=nx>FindClassNames</span><span class=p>(</span><span class=s>&quot;He&quot;</span><span class=p>)</span>

    <span class=nx>thisIndex</span> <span class=p>=</span> <span class=nx>IndexOfGeneric</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>foundClassNames</span><span class=p>),</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>foundClassNames</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=s>&quot;HelloWorld&quot;</span> <span class=p>})</span>
    <span class=nx>s</span><span class=p>.</span><span class=nx>Equal</span><span class=p>(</span><span class=nx>thisIndex</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>

    <span class=nx>thisIndex</span> <span class=p>=</span> <span class=nx>IndexOfGeneric</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>foundClassNames</span><span class=p>),</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>foundClassNames</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=s>&quot;HelloWeirWorld&quot;</span> <span class=p>})</span>
    <span class=nx>s</span><span class=p>.</span><span class=nx>Equal</span><span class=p>(</span><span class=nx>thisIndex</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>

    <span class=nx>s</span><span class=p>.</span><span class=nx>Equal</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>foundClassNames</span><span class=p>),</span> <span class=mi>2</span><span class=p>)</span>


    <span class=nx>foundClassNames</span> <span class=p>=</span> <span class=nx>FindClassNames</span><span class=p>(</span><span class=s>&quot;Hi&quot;</span><span class=p>)</span>

    <span class=nx>thisIndex</span> <span class=p>=</span> <span class=nx>IndexOfGeneric</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>foundClassNames</span><span class=p>),</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>foundClassNames</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=s>&quot;HiWorld&quot;</span> <span class=p>})</span>
    <span class=nx>s</span><span class=p>.</span><span class=nx>Equal</span><span class=p>(</span><span class=nx>thisIndex</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>

    <span class=nx>s</span><span class=p>.</span><span class=nx>Equal</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>foundClassNames</span><span class=p>),</span> <span class=mi>1</span><span class=p>)</span>


    <span class=nx>foundClassNames</span> <span class=p>=</span> <span class=nx>FindClassNames</span><span class=p>(</span><span class=s>&quot;HWW&quot;</span><span class=p>)</span>

    <span class=nx>thisIndex</span> <span class=p>=</span> <span class=nx>IndexOfGeneric</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>foundClassNames</span><span class=p>),</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>foundClassNames</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=o>==</span> <span class=s>&quot;HelloWeirWorld&quot;</span> <span class=p>})</span>
    <span class=nx>s</span><span class=p>.</span><span class=nx>Equal</span><span class=p>(</span><span class=nx>thisIndex</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>,</span> <span class=kc>true</span><span class=p>)</span>

    <span class=nx>s</span><span class=p>.</span><span class=nx>Equal</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>foundClassNames</span><span class=p>),</span> <span class=mi>1</span><span class=p>)</span>

<span class=p>}</span>

<span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>mySuite</span><span class=p>)</span> <span class=nx>TestRemoveItemsFromInvoice</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>s</span><span class=p>.</span><span class=nx>Pending</span><span class=p>()</span>
<span class=p>}</span>
</code></pre></div><p><br><hr><br></p><h2>Test Results</h2><pre><code>
Testing started at 5:22 PM ...
=== RUN TestRunner

class_filter.mySuite:

    [32mOK[0m TestClassNameFilter           (11 assertion(s))
    [32mOK[0m TestPopulateTree              (4 assertion(s))
    [33mPE[0m TestRemoveItemsFromInvoice    (0 assertion(s))

3 tests, 2 passed, 0 failed, 0 expected failures, 1 pending, 0 with no assertions
--- PASS: TestRunner (0.00 seconds)
PASS
ok      bitbucket.org/l3x/class_filter  0.013s
<span style=color:blue>
Process finished with exit code 0
</span>
</code></pre><p><br><hr><br></p><h2>Notes</h2><h3>The Data Structures</h3><p>We use a tree structure, composed of linked Levels, composed of maps that map to the first letter of the class names:<br><br>Here are the structures we use:</p><div class=highlight><pre><code class="go language-go" data-lang=go><span class=c1>// Level is the node that contains the alpha map for each level</span>
<span class=c1>// Each level contains words that match that level&#39;s levelNumber</span>
<span class=c1>// The first letter of each entry in the alpha map matches that key, e.g. &quot;Hi&quot; is at level 2 at key &quot;H&quot;</span>
<span class=kd>type</span> <span class=nx>Level</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>alpha</span>       <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span>  
    <span class=nx>levelNumber</span> <span class=kt>int</span>
    <span class=nx>nextLevel</span>   <span class=o>*</span><span class=nx>Level</span>
<span class=p>}</span>

<span class=c1>// Tree contains the pointer to the top of the tree of levels</span>
<span class=kd>type</span> <span class=nx>Tree</span> <span class=kd>struct</span> <span class=p>{</span>
    <span class=nx>top</span>     <span class=o>*</span><span class=nx>Level</span>
<span class=p>}</span>
<span class=c1>// The Top() method points to the top of the tree. </span>
<span class=c1>// Only downward navigation is supported.</span>
<span class=kd>func</span> <span class=p>(</span><span class=nx>tree</span> <span class=o>*</span><span class=nx>Tree</span><span class=p>)</span> <span class=nx>Top</span><span class=p>()</span> <span class=o>*</span><span class=nx>Level</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>tree</span><span class=p>.</span><span class=nx>top</span>
<span class=p>}</span>
</code></pre></div><p><br></p><p>If you were to change the package name to <strong>main</strong> and rename the function mainSTOP to main, it would give a feel for how the classNames are stored in the tree and show a few examples of the filter in action:</p><pre><code>
TREE:
alpha[H] (6) : map[HiWorld:HiWorld]
alpha[H] (9) : map[HelloWorld:HelloWorld]
alpha[W] (9) : map[WordlHello:WordlHello]
alpha[H] (13) : map[HelloWeirWorld:HelloWeirWorld]
--------------------------------------------------
ClassNames found for input: HW
HiWorld
HelloWorld
HelloWeirWorld
--------------------------------------------------
ClassNames found for input: He
HelloWorld
HelloWeirWorld
--------------------------------------------------
ClassNames found for input: Hi
HiWorld
--------------------------------------------------
ClassNames found for input: HWW
HelloWeirWorld
--------------------------------------------------
</code></pre><p><br></p><h3>A Look at the Tree</h3><p>If you were to uncomment the <code>Printf(&quot;thisLevel: %v\n&quot;, *thisLevel)</code> line in PopulateTree you can see where the class names are stored:</p><pre><code style="font-size: .8em">
thisLevel: {map[Z:map[] k:map[] r:map[] x:map[] L:map[] Q:map[] U:map[] j:map[] q:map[] G:map[] c:map[] a:map[] H:map[] E:map[] o:map[] h:map[] v:map[] d:map[] M:map[] N:map[] u:map[] X:map[] e:map[] B:map[] J:map[] s:map[] l:map[] g:map[] P:map[] m:map[] b:map[] f:map[] A:map[] C:map[] z:map[] R:map[] S:map[] I:map[] w:map[] Y:map[] F:map[] D:map[] T:map[] K:map[] V:map[] p:map[] y:map[] n:map[] O:map[] W:map[] i:map[] t:map[]] 1 <nil>}
thisLevel: {map[U:map[] D:map[] E:map[] i:map[] o:map[] X:map[] I:map[] e:map[] J:map[] M:map[] d:map[] y:map[] n:map[] T:map[] j:map[] x:map[] P:map[] R:map[] c:map[] w:map[] B:map[] H:map[] a:map[] h:map[] q:map[] K:map[] Q:map[] W:map[] N:map[] V:map[] s:map[] C:map[] A:map[] G:map[] g:map[] u:map[] F:map[] Y:map[] p:map[] f:map[] z:map[] v:map[] k:map[] O:map[] r:map[] m:map[] S:map[] L:map[] b:map[] t:map[] Z:map[] l:map[]] 2 <nil>}
thisLevel: {map[Z:map[] f:map[] c:map[] m:map[] N:map[] a:map[] H:map[] Y:map[] l:map[] n:map[] O:map[] q:map[] M:map[] V:map[] D:map[] k:map[] R:map[] U:map[] s:map[] C:map[] x:map[] Q:map[] F:map[] r:map[] b:map[] X:map[] j:map[] P:map[] J:map[] L:map[] W:map[] i:map[] I:map[] g:map[] B:map[] o:map[] p:map[] A:map[] G:map[] S:map[] d:map[] t:map[] z:map[] T:map[] E:map[] h:map[] v:map[] K:map[] e:map[] w:map[] u:map[] y:map[]] 3 <nil>}
thisLevel: {map[H:map[] u:map[] n:map[] T:map[] B:map[] W:map[] m:map[] U:map[] o:map[] d:map[] V:map[] Y:map[] X:map[] Z:map[] z:map[] L:map[] Q:map[] K:map[] G:map[] r:map[] g:map[] J:map[] p:map[] s:map[] v:map[] x:map[] O:map[] c:map[] M:map[] F:map[] w:map[] t:map[] a:map[] f:map[] C:map[] D:map[] e:map[] i:map[] j:map[] R:map[] E:map[] l:map[] q:map[] S:map[] b:map[] h:map[] A:map[] k:map[] P:map[] I:map[] N:map[] y:map[]] 4 <nil>}
thisLevel: {map[H:map[] D:map[] T:map[] j:map[] r:map[] J:map[] d:map[] t:map[] K:map[] m:map[] L:map[] e:map[] o:map[] p:map[] h:map[] G:map[] S:map[] a:map[] U:map[] l:map[] c:map[] M:map[] u:map[] Y:map[] v:map[] x:map[] b:map[] V:map[] s:map[] n:map[] A:map[] R:map[] g:map[] B:map[] F:map[] w:map[] N:map[] C:map[] k:map[] O:map[] q:map[] W:map[] i:map[] E:map[] X:map[] Z:map[] f:map[] z:map[] P:map[] Q:map[] y:map[] I:map[]] 5 <nil>}
thisLevel: {map[O:map[] N:map[] d:map[] U:map[] o:map[] l:map[] x:map[] c:map[] W:map[] H:map[] z:map[] T:map[] s:map[] v:map[] A:map[] Q:map[] t:map[] M:map[] f:map[] i:map[] r:map[] S:map[] I:map[] g:map[] e:map[] y:map[] E:map[] n:map[] a:map[] u:map[] p:map[] D:map[] L:map[] B:map[] b:map[] V:map[] h:map[] C:map[] R:map[] q:map[] J:map[] w:map[] Y:map[] Z:map[] P:map[] G:map[] K:map[] m:map[] F:map[] X:map[] j:map[] k:map[]] 6 <nil>}
thisLevel: {map[E:map[] n:map[] N:map[] F:map[] Z:map[] x:map[] P:map[] m:map[] K:map[] S:map[] M:map[] o:map[] z:map[] T:map[] l:map[] q:map[] R:map[] J:map[] X:map[] h:map[] C:map[] k:map[] O:map[] u:map[] U:map[] Y:map[] f:map[] w:map[] b:map[] t:map[] p:map[] D:map[] v:map[] j:map[] G:map[] i:map[] Q:map[] r:map[] g:map[] H:map[] V:map[] a:map[] A:map[] c:map[] L:map[] d:map[] W:map[] y:map[] s:map[] I:map[] e:map[] B:map[]] 7 <nil>}
thisLevel: {map[M:map[] H:map[] h:map[] z:map[] x:map[] c:map[] m:map[] d:map[] i:map[] B:map[] t:map[] N:map[] Y:map[] X:map[] v:map[] Q:map[] P:map[] r:map[] I:map[] A:map[] w:map[] b:map[] a:map[] u:map[] o:map[] p:map[] Z:map[] L:map[] G:map[] T:map[] j:map[] k:map[] O:map[] K:map[] U:map[] V:map[] y:map[] l:map[] q:map[] S:map[] J:map[] C:map[] f:map[] s:map[] R:map[] g:map[] E:map[] e:map[] F:map[] D:map[] n:map[] W:map[]] 8 <nil>}
thisLevel: {map[D:map[] G:map[] J:map[] M:map[] p:map[] y:map[] v:map[] O:map[] c:map[] i:map[] W:map[] d:map[] H:map[] f:map[] j:map[] m:map[] w:map[] h:map[] k:map[] l:map[] n:map[] r:map[] x:map[] I:map[] N:map[] t:map[] u:map[] F:map[] Y:map[] s:map[] A:map[] T:map[] L:map[] Q:map[] a:map[] X:map[] R:map[] S:map[] g:map[] B:map[] b:map[] V:map[] C:map[] K:map[] e:map[] o:map[] E:map[] Z:map[] z:map[] P:map[] q:map[] U:map[]] 9 <nil>}
thisLevel: {map[G:map[] J:map[] D:map[] p:map[] y:map[] v:map[] O:map[] c:map[] i:map[] M:map[] d:map[] H:map[HelloWorld:HelloWorld] f:map[] j:map[] m:map[] w:map[] W:map[] k:map[] l:map[] n:map[] r:map[] x:map[] I:map[] N:map[] h:map[] u:map[] F:map[] Y:map[] s:map[] A:map[] T:map[] L:map[] t:map[] a:map[] X:map[] R:map[] S:map[] g:map[] B:map[] Q:map[] V:map[] C:map[] K:map[] e:map[] b:map[] E:map[] Z:map[] z:map[] P:map[] q:map[] U:map[] o:map[]] 9 <nil>}
thisLevel: {map[L:map[] Q:map[] U:map[] Z:map[] k:map[] r:map[] x:map[] a:map[] H:map[] E:map[] j:map[] q:map[] G:map[] c:map[] o:map[] h:map[] v:map[] X:map[] e:map[] B:map[] J:map[] d:map[] M:map[] N:map[] u:map[] s:map[] l:map[] g:map[] b:map[] f:map[] A:map[] P:map[] m:map[] I:map[] w:map[] Y:map[] F:map[] C:map[] z:map[] R:map[] S:map[] V:map[] p:map[] y:map[] D:map[] T:map[] K:map[] W:map[] i:map[] t:map[] n:map[] O:map[]] 1 0x2081f5740}
thisLevel: {map[U:map[] D:map[] E:map[] i:map[] o:map[] X:map[] I:map[] T:map[] j:map[] e:map[] J:map[] M:map[] d:map[] y:map[] n:map[] x:map[] P:map[] R:map[] c:map[] K:map[] w:map[] B:map[] H:map[] a:map[] h:map[] q:map[] Q:map[] W:map[] N:map[] V:map[] s:map[] C:map[] A:map[] G:map[] g:map[] v:map[] k:map[] u:map[] F:map[] Y:map[] p:map[] f:map[] z:map[] O:map[] r:map[] m:map[] S:map[] L:map[] b:map[] t:map[] Z:map[] l:map[]] 2 0x208213820}
thisLevel: {map[Y:map[] Z:map[] f:map[] c:map[] m:map[] N:map[] a:map[] H:map[] k:map[] l:map[] n:map[] O:map[] q:map[] M:map[] V:map[] D:map[] R:map[] x:map[] U:map[] s:map[] C:map[] Q:map[] F:map[] r:map[] i:map[] b:map[] X:map[] j:map[] P:map[] J:map[] L:map[] W:map[] I:map[] A:map[] g:map[] B:map[] o:map[] p:map[] T:map[] G:map[] S:map[] d:map[] t:map[] z:map[] y:map[] E:map[] h:map[] v:map[] K:map[] e:map[] w:map[] u:map[]] 3 0x208213f40}
thisLevel: {map[B:map[] W:map[] H:map[] u:map[] n:map[] T:map[] U:map[] o:map[] m:map[] Z:map[] z:map[] L:map[] Q:map[] d:map[] V:map[] Y:map[] X:map[] K:map[] J:map[] p:map[] G:map[] r:map[] g:map[] c:map[] M:map[] F:map[] s:map[] v:map[] x:map[] O:map[] C:map[] D:map[] e:map[] i:map[] w:map[] t:map[] a:map[] f:map[] j:map[] R:map[] b:map[] h:map[] E:map[] l:map[] q:map[] S:map[] N:map[] y:map[] A:map[] k:map[] P:map[] I:map[]] 4 0x208200160}
thisLevel: {map[D:map[] T:map[] j:map[] r:map[] J:map[] d:map[] H:map[] K:map[] m:map[] L:map[] e:map[] t:map[] p:map[] h:map[] G:map[] S:map[] a:map[] U:map[] o:map[] c:map[] M:map[] u:map[] l:map[] v:map[] x:map[] b:map[] V:map[] Y:map[] n:map[] A:map[] R:map[] g:map[] B:map[] F:map[] s:map[] N:map[] C:map[] k:map[] O:map[] q:map[] W:map[] i:map[] w:map[] X:map[] Z:map[] f:map[] z:map[] P:map[] Q:map[] y:map[] E:map[] I:map[]] 5 0x20821e240}
thisLevel: {map[N:map[] d:map[] U:map[] o:map[] O:map[] c:map[] W:map[] H:map[] z:map[] T:map[] l:map[] x:map[] A:map[] Q:map[] t:map[] M:map[] f:map[] s:map[] v:map[] i:map[] r:map[] S:map[] I:map[] e:map[] y:map[] E:map[] n:map[] g:map[] p:map[] D:map[] L:map[] B:map[] b:map[] V:map[] a:map[] u:map[] h:map[] C:map[] R:map[] J:map[] w:map[] Y:map[] Z:map[] q:map[] K:map[] m:map[] F:map[] X:map[] j:map[] k:map[] P:map[] G:map[]] 6 0x20821e900}
thisLevel: {map[O:map[] N:map[] d:map[] U:map[] o:map[] l:map[] x:map[] c:map[] W:map[] H:map[HiWorld:HiWorld] z:map[] T:map[] s:map[] v:map[] A:map[] Q:map[] t:map[] M:map[] f:map[] i:map[] r:map[] S:map[] I:map[] g:map[] e:map[] y:map[] E:map[] n:map[] a:map[] u:map[] p:map[] D:map[] L:map[] B:map[] b:map[] V:map[] h:map[] C:map[] R:map[] q:map[] J:map[] w:map[] Y:map[] Z:map[] P:map[] G:map[] K:map[] m:map[] F:map[] X:map[] j:map[] k:map[]] 6 0x20821e900}
thisLevel: {map[L:map[] Q:map[] U:map[] Z:map[] k:map[] r:map[] x:map[] a:map[] H:map[] E:map[] j:map[] q:map[] G:map[] c:map[] o:map[] h:map[] v:map[] e:map[] B:map[] J:map[] d:map[] M:map[] N:map[] u:map[] X:map[] s:map[] l:map[] g:map[] b:map[] f:map[] A:map[] P:map[] m:map[] w:map[] Y:map[] F:map[] C:map[] z:map[] R:map[] S:map[] I:map[] V:map[] p:map[] y:map[] D:map[] T:map[] K:map[] W:map[] i:map[] t:map[] n:map[] O:map[]] 1 0x2081f5740}
thisLevel: {map[U:map[] D:map[] E:map[] i:map[] o:map[] X:map[] I:map[] j:map[] e:map[] J:map[] M:map[] d:map[] y:map[] n:map[] T:map[] x:map[] P:map[] R:map[] c:map[] w:map[] B:map[] H:map[] a:map[] h:map[] q:map[] K:map[] Q:map[] W:map[] N:map[] V:map[] s:map[] C:map[] A:map[] G:map[] g:map[] k:map[] u:map[] F:map[] Y:map[] p:map[] f:map[] z:map[] v:map[] O:map[] r:map[] m:map[] S:map[] L:map[] b:map[] t:map[] Z:map[] l:map[]] 2 0x208213820}
thisLevel: {map[a:map[] H:map[] Y:map[] Z:map[] f:map[] c:map[] m:map[] N:map[] V:map[] D:map[] k:map[] l:map[] n:map[] O:map[] q:map[] M:map[] R:map[] s:map[] C:map[] x:map[] U:map[] F:map[] r:map[] Q:map[] L:map[] W:map[] i:map[] b:map[] X:map[] j:map[] P:map[] J:map[] I:map[] o:map[] p:map[] A:map[] g:map[] B:map[] t:map[] z:map[] T:map[] G:map[] S:map[] d:map[] w:map[] u:map[] y:map[] E:map[] h:map[] v:map[] K:map[] e:map[]] 3 0x208213f40}
thisLevel: {map[T:map[] B:map[] W:map[] H:map[] u:map[] n:map[] U:map[] o:map[] m:map[] X:map[] Z:map[] z:map[] L:map[] Q:map[] d:map[] V:map[] Y:map[] K:map[] J:map[] p:map[] G:map[] r:map[] g:map[] O:map[] c:map[] M:map[] F:map[] s:map[] v:map[] x:map[] f:map[] C:map[] D:map[] e:map[] i:map[] w:map[] t:map[] a:map[] j:map[] R:map[] S:map[] b:map[] h:map[] E:map[] l:map[] q:map[] I:map[] N:map[] y:map[] A:map[] k:map[] P:map[]] 4 0x208200160}
thisLevel: {map[j:map[] r:map[] J:map[] d:map[] H:map[] D:map[] T:map[] L:map[] e:map[] t:map[] K:map[] m:map[] G:map[] S:map[] a:map[] U:map[] o:map[] p:map[] h:map[] M:map[] u:map[] l:map[] c:map[] b:map[] V:map[] Y:map[] v:map[] x:map[] R:map[] g:map[] B:map[] F:map[] s:map[] n:map[] A:map[] k:map[] O:map[] q:map[] W:map[] i:map[] w:map[] N:map[] C:map[] f:map[] z:map[] P:map[] Q:map[] y:map[] E:map[] X:map[] Z:map[] I:map[]] 5 0x20821e240}
thisLevel: {map[N:map[] d:map[] U:map[] o:map[] O:map[] x:map[] c:map[] W:map[] H:map[HiWorld:HiWorld] z:map[] T:map[] l:map[] v:map[] A:map[] Q:map[] t:map[] M:map[] f:map[] s:map[] i:map[] r:map[] S:map[] I:map[] e:map[] y:map[] E:map[] n:map[] g:map[] u:map[] p:map[] D:map[] L:map[] B:map[] b:map[] V:map[] a:map[] h:map[] C:map[] R:map[] J:map[] w:map[] Y:map[] Z:map[] q:map[] G:map[] K:map[] m:map[] F:map[] X:map[] j:map[] k:map[] P:map[]] 6 0x20821e900}
thisLevel: {map[N:map[] F:map[] E:map[] n:map[] m:map[] K:map[] S:map[] M:map[] o:map[] Z:map[] x:map[] P:map[] q:map[] R:map[] J:map[] X:map[] z:map[] T:map[] l:map[] O:map[] u:map[] U:map[] h:map[] C:map[] k:map[] w:map[] b:map[] Y:map[] f:map[] v:map[] j:map[] G:map[] i:map[] Q:map[] t:map[] p:map[] D:map[] r:map[] g:map[] A:map[] c:map[] L:map[] d:map[] H:map[] V:map[] a:map[] I:map[] e:map[] B:map[] W:map[] y:map[] s:map[]] 7 0x2082129c0}
thisLevel: {map[x:map[] c:map[] m:map[] d:map[] M:map[] H:map[] h:map[] z:map[] Y:map[] X:map[] v:map[] Q:map[] i:map[] B:map[] t:map[] N:map[] A:map[] P:map[] r:map[] I:map[] o:map[] p:map[] Z:map[] L:map[] w:map[] b:map[] a:map[] u:map[] T:map[] G:map[] U:map[] j:map[] k:map[] O:map[] K:map[] S:map[] J:map[] V:map[] y:map[] l:map[] q:map[] C:map[] E:map[] f:map[] s:map[] R:map[] g:map[] W:map[] e:map[] F:map[] D:map[] n:map[]] 8 0x208200ae0}
thisLevel: {map[J:map[] D:map[] G:map[] O:map[] c:map[] i:map[] M:map[] p:map[] y:map[] v:map[] j:map[] m:map[] w:map[] W:map[] d:map[] H:map[HelloWorld:HelloWorld] f:map[] r:map[] x:map[] I:map[] N:map[] h:map[] k:map[] l:map[] n:map[] s:map[] A:map[] T:map[] L:map[] t:map[] u:map[] F:map[] Y:map[] S:map[] g:map[] B:map[] Q:map[] a:map[] X:map[] R:map[] e:map[] b:map[] V:map[] C:map[] K:map[] P:map[] q:map[] U:map[] o:map[] E:map[] Z:map[] z:map[]] 9 <nil>}
thisLevel: {map[G:map[] J:map[] D:map[] p:map[] y:map[] v:map[] O:map[] c:map[] i:map[] M:map[] d:map[] H:map[HelloWorld:HelloWorld] f:map[] j:map[] m:map[] w:map[] W:map[WordlHello:WordlHello] k:map[] l:map[] n:map[] r:map[] x:map[] I:map[] N:map[] h:map[] u:map[] F:map[] Y:map[] s:map[] A:map[] T:map[] L:map[] t:map[] a:map[] X:map[] R:map[] S:map[] g:map[] B:map[] Q:map[] V:map[] C:map[] K:map[] e:map[] b:map[] E:map[] Z:map[] z:map[] P:map[] q:map[] U:map[] o:map[]] 9 <nil>}
thisLevel: {map[k:map[] r:map[] x:map[] L:map[] Q:map[] U:map[] Z:map[] q:map[] G:map[] c:map[] a:map[] H:map[] E:map[] j:map[] o:map[] h:map[] v:map[] M:map[] N:map[] u:map[] X:map[] e:map[] B:map[] J:map[] d:map[] s:map[] l:map[] g:map[] m:map[] b:map[] f:map[] A:map[] P:map[] z:map[] R:map[] S:map[] I:map[] w:map[] Y:map[] F:map[] C:map[] T:map[] K:map[] V:map[] p:map[] y:map[] D:map[] O:map[] W:map[] i:map[] t:map[] n:map[]] 1 0x2081f5740}
thisLevel: {map[U:map[] D:map[] E:map[] i:map[] o:map[] X:map[] I:map[] j:map[] e:map[] J:map[] M:map[] d:map[] y:map[] n:map[] T:map[] x:map[] P:map[] R:map[] c:map[] w:map[] B:map[] H:map[] a:map[] h:map[] q:map[] K:map[] Q:map[] W:map[] N:map[] V:map[] s:map[] C:map[] A:map[] G:map[] g:map[] k:map[] u:map[] F:map[] Y:map[] p:map[] f:map[] z:map[] v:map[] O:map[] r:map[] m:map[] S:map[] L:map[] b:map[] t:map[] Z:map[] l:map[]] 2 0x208213820}
thisLevel: {map[a:map[] H:map[] Y:map[] Z:map[] f:map[] c:map[] m:map[] N:map[] V:map[] D:map[] k:map[] l:map[] n:map[] O:map[] q:map[] M:map[] R:map[] s:map[] C:map[] x:map[] U:map[] F:map[] r:map[] Q:map[] L:map[] W:map[] i:map[] b:map[] X:map[] j:map[] P:map[] J:map[] I:map[] o:map[] p:map[] A:map[] g:map[] B:map[] t:map[] z:map[] T:map[] G:map[] S:map[] d:map[] w:map[] u:map[] y:map[] E:map[] h:map[] v:map[] K:map[] e:map[]] 3 0x208213f40}
thisLevel: {map[T:map[] B:map[] W:map[] H:map[] u:map[] n:map[] U:map[] o:map[] m:map[] X:map[] Z:map[] z:map[] L:map[] Q:map[] d:map[] V:map[] Y:map[] K:map[] J:map[] p:map[] G:map[] r:map[] g:map[] O:map[] c:map[] M:map[] F:map[] s:map[] v:map[] x:map[] f:map[] C:map[] D:map[] e:map[] i:map[] w:map[] t:map[] a:map[] j:map[] R:map[] S:map[] b:map[] h:map[] E:map[] l:map[] q:map[] I:map[] N:map[] y:map[] A:map[] k:map[] P:map[]] 4 0x208200160}
thisLevel: {map[H:map[] D:map[] T:map[] j:map[] r:map[] J:map[] d:map[] t:map[] K:map[] m:map[] L:map[] e:map[] o:map[] p:map[] h:map[] G:map[] S:map[] a:map[] U:map[] l:map[] c:map[] M:map[] u:map[] Y:map[] v:map[] x:map[] b:map[] V:map[] s:map[] n:map[] A:map[] R:map[] g:map[] B:map[] F:map[] w:map[] N:map[] C:map[] k:map[] O:map[] q:map[] W:map[] i:map[] E:map[] X:map[] Z:map[] f:map[] z:map[] P:map[] Q:map[] y:map[] I:map[]] 5 0x20821e240}
thisLevel: {map[O:map[] N:map[] d:map[] U:map[] o:map[] l:map[] x:map[] c:map[] W:map[] H:map[HiWorld:HiWorld] z:map[] T:map[] s:map[] v:map[] A:map[] Q:map[] t:map[] M:map[] f:map[] i:map[] r:map[] S:map[] I:map[] g:map[] e:map[] y:map[] E:map[] n:map[] a:map[] u:map[] p:map[] D:map[] L:map[] B:map[] b:map[] V:map[] h:map[] C:map[] R:map[] q:map[] J:map[] w:map[] Y:map[] Z:map[] P:map[] G:map[] K:map[] m:map[] F:map[] X:map[] j:map[] k:map[]] 6 0x20821e900}
thisLevel: {map[N:map[] F:map[] E:map[] n:map[] S:map[] M:map[] o:map[] Z:map[] x:map[] P:map[] m:map[] K:map[] J:map[] X:map[] z:map[] T:map[] l:map[] q:map[] R:map[] u:map[] U:map[] h:map[] C:map[] k:map[] O:map[] w:map[] b:map[] Y:map[] f:map[] G:map[] i:map[] Q:map[] t:map[] p:map[] D:map[] v:map[] j:map[] r:map[] g:map[] L:map[] d:map[] H:map[] V:map[] a:map[] A:map[] c:map[] e:map[] B:map[] W:map[] y:map[] s:map[] I:map[]] 7 0x2082129c0}
thisLevel: {map[M:map[] H:map[] h:map[] z:map[] x:map[] c:map[] m:map[] d:map[] i:map[] B:map[] t:map[] N:map[] Y:map[] X:map[] v:map[] Q:map[] P:map[] r:map[] I:map[] A:map[] w:map[] b:map[] a:map[] u:map[] o:map[] p:map[] Z:map[] L:map[] G:map[] T:map[] j:map[] k:map[] O:map[] K:map[] U:map[] V:map[] y:map[] l:map[] q:map[] S:map[] J:map[] C:map[] f:map[] s:map[] R:map[] g:map[] E:map[] e:map[] F:map[] D:map[] n:map[] W:map[]] 8 0x208200ae0}
thisLevel: {map[G:map[] J:map[] D:map[] p:map[] y:map[] v:map[] O:map[] c:map[] i:map[] M:map[] d:map[] H:map[HelloWorld:HelloWorld] f:map[] j:map[] m:map[] w:map[] W:map[WordlHello:WordlHello] k:map[] l:map[] n:map[] r:map[] x:map[] I:map[] N:map[] h:map[] u:map[] F:map[] Y:map[] s:map[] A:map[] T:map[] L:map[] t:map[] a:map[] X:map[] R:map[] S:map[] g:map[] B:map[] Q:map[] V:map[] C:map[] K:map[] e:map[] b:map[] E:map[] Z:map[] z:map[] P:map[] q:map[] U:map[] o:map[]] 9 <nil>}
thisLevel: {map[i:map[] B:map[] M:map[] Y:map[] o:map[] x:map[] s:map[] c:map[] v:map[] I:map[] Q:map[] t:map[] V:map[] p:map[] F:map[] E:map[] m:map[] W:map[] y:map[] D:map[] X:map[] T:map[] O:map[] j:map[] G:map[] L:map[] H:map[] u:map[] l:map[] n:map[] A:map[] K:map[] J:map[] U:map[] r:map[] g:map[] R:map[] P:map[] e:map[] b:map[] a:map[] f:map[] C:map[] z:map[] q:map[] S:map[] w:map[] N:map[] d:map[] Z:map[] h:map[] k:map[]] 10 <nil>}
thisLevel: {map[D:map[] X:map[] x:map[] w:map[] B:map[] W:map[] U:map[] o:map[] P:map[] q:map[] K:map[] M:map[] d:map[] F:map[] k:map[] l:map[] S:map[] N:map[] a:map[] j:map[] g:map[] R:map[] b:map[] t:map[] v:map[] T:map[] G:map[] Y:map[] C:map[] A:map[] e:map[] i:map[] J:map[] L:map[] V:map[] I:map[] c:map[] Q:map[] H:map[] s:map[] m:map[] u:map[] f:map[] z:map[] O:map[] r:map[] n:map[] y:map[] p:map[] h:map[] E:map[] Z:map[]] 11 <nil>}
thisLevel: {map[W:map[] d:map[] M:map[] y:map[] I:map[] p:map[] f:map[] v:map[] A:map[] S:map[] J:map[] u:map[] h:map[] C:map[] H:map[] o:map[] L:map[] Q:map[] e:map[] w:map[] b:map[] t:map[] s:map[] x:map[] R:map[] c:map[] j:map[] i:map[] B:map[] Y:map[] F:map[] X:map[] z:map[] q:map[] O:map[] N:map[] V:map[] U:map[] E:map[] n:map[] T:map[] K:map[] Z:map[] l:map[] g:map[] m:map[] a:map[] D:map[] k:map[] P:map[] r:map[] G:map[]] 12 <nil>}
thisLevel: {map[F:map[] U:map[] Y:map[] o:map[] h:map[] D:map[] Q:map[] a:map[] I:map[] S:map[] Z:map[] n:map[] M:map[] s:map[] p:map[] y:map[] z:map[] T:map[] O:map[] q:map[] W:map[] H:map[] r:map[] K:map[] A:map[] x:map[] g:map[] w:map[] V:map[] L:map[] k:map[] R:map[] i:map[] B:map[] E:map[] m:map[] c:map[] N:map[] C:map[] t:map[] u:map[] X:map[] f:map[] v:map[] j:map[] J:map[] b:map[] l:map[] P:map[] G:map[] e:map[] d:map[]] 13 <nil>}
thisLevel: {map[Y:map[] o:map[] h:map[] D:map[] Q:map[] a:map[] F:map[] U:map[] Z:map[] n:map[] I:map[] S:map[] M:map[] s:map[] z:map[] T:map[] O:map[] q:map[] W:map[] H:map[HelloWeirWorld:HelloWeirWorld] p:map[] y:map[] r:map[] K:map[] g:map[] w:map[] V:map[] A:map[] x:map[] R:map[] i:map[] B:map[] L:map[] k:map[] c:map[] N:map[] C:map[] E:map[] m:map[] X:map[] f:map[] v:map[] j:map[] J:map[] b:map[] t:map[] u:map[] l:map[] P:map[] e:map[] d:map[] G:map[]] 13 <nil>}
</nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></code></pre><h3>A Better Way?</h3><p>In this code example, the class names are stored in a tree with several levels of hash maps to hash maps.</p><p>There are no more levels than there are letters in the longest class name.</p><p>I tried to use maps as much as possible, but some slice element iteration and manipulation and linked node navigation also exists.</p><p>Can you think of a more efficient way to store/filter the class names?</p><p>If so, please share your thoughts.</p><p>Thanks! ~ Lex<br></p><hr><h2>References</h2><ul><li><a href=https://github.com/l3x/golang-code-examples>Golang Code Examples</a></li><li><a href=https://github.com/go-goodies/go_utils>go-goodies/go_utils</a></li><li><a href="http://tour.golang.org/">Golang Tour</a></li></ul></section></div><!-- Add Disqus comments. --><div id=disqus_thread></div><script type=text/javascript>/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'golang-code-examples'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();</script><noscript>Please enable JavaScript to view the <a href=http://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=http://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><div class=footer><div class=contact><div id=name-gravatar class=float-left><span>By Lex Sheehan</span> <span class=l3x-gravatar></span></div><div class=float-right><strong>It's Go Time!</strong></div></div></div><div class=license-notice>The content of this site is licensed under the <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons 3.0License</a> and code is licensed under a <a href=https://github.com/l3x/golang-code-examples/blob/master/LICENSE>BSD license</a></div></div><script src=/golang-code-examples/scripts/scripts.db44.js></script></body></html>
